/**
 * 1. build_phase 별 아래의 폴더와 파일을 모두 lib/gen 에 copy
 * 2. appVersion 을 pubspec.yaml 에서 읽어들이기
 * 3. build 시점 git hash 값을 git command 를 통해 읽어들이기
 * 4. build 시점 Date 정보 읽어들이기
 * 5. lib/gen 아래에 정보를 추가하기
 */

// 1. build_phase 별 아래의 폴더와 파일을 모두 lib/gen 에 copy 하는 로직
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;

 final File genDir = new File("lib/gen");
 final File scriptDir = new File("buildScript");
 final File versionInfoFile = new File(genDir, "version_info.dart");
 int exitCode = 0;

 final List<String> parseArgs() {
    final String rawArgs = System.getProperty("args");
    if (rawArgs == null) {
        return new ArrayList<String>();
    } else{
        return Array.stream(rawArgs.split(" ")).collect(Collectors.toList());
    }
 }

// lib/gen 에 이미 폴더가 복사되어있을 경우 삭제한다.
 final boolean cleanGenDir() {
    if (!genDir.exists()) {
        return true;
    }

    return rmdirs(genDir);
 }

 // 파괴적인 연산이므로 주의해야 한다.
 final boolean putFilesPerBuildPhase(final String phase) {
    class BooleanRef {
        public boolean value = false;

        public BooleanRef(final boolean initialValue) {
            this.value = initialValue;
        }
    }

    final BooleanRef state = new BooleanRef(true);
    try {
        final File sourceDir = new File(scriptDir, phase);
        Files.walk(sourceDir.toPath())
        .forEach(source -> {
            Path destination = Paths.get(genDir.toString(), source.toString().substring(sourceDir.toString().length()));

            try {
                Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);
            } catch (IOException e) {
                System.err.println(e.getClass().getName() + ": " + e.getMessage());
                state.value = false;
            }
        });
    } catch (final Throwable e) {
        System.err.println(e.getClass().getName() + ": 파일 기록 실패 (" + e.getMessage() + ")");
        return false;
    }

    return state.value;
 }

// 2. appVersion 을 pubspec.yaml 에서 읽어들이는 로직
 final String readVersionFromPubspec() {
    final File pubFile = new File("pubspec.yaml");

    try (final BufferedReader br = new BufferedReader(new FileReader(pubFile))) {
        Sting line;
        while ((line = br.readLine()) != null) {
            if (line.startsWith("version") && line.split(":").length > 1) {
                line = line.split(":")[1].trim();
                break;
            }
        }

        return line;
    } catch (IOException e) {
        return null;
    }
 }

// 3. build 시점 git hash 값을 git command 를 통해 읽어들이는 로직
 final String extractGitHash() {
    final String command = "git rev-parse --short HEAD";
    final ProcessBuilder pb = new ProcessBuilder("sh", "-c", command);
    final Process process;

    try {
        process = pb.start();
        final int exitCode = process.waitFor();
        if (exitCode > 0) {
            throw new IOException("Exit code > 0");
        }

        final BufferedReader stdInput = new BufferedReader(new InputStreamReader(process.getInputStream()));
        return stdInput.lines().collect(Collectors.joining("\n"));
    } catch (final Throwable e) {
        System.err.println("exec '" + command + "' 에 실패했습니다.");
        return null;
    }
 }

 // 4. 앞에서 얻어온 정보를 build 시점 Date 를 추가해서 'version_info.dart.codegen' %S 파일에 넣는 로직
 final boolean putVersionInfo(final String appVersion, final String gitHash) {
    final File versionInfoTemplateFile = new File(scriptDir, "version_info.dart.codegen");
    final String content;

    try {
        content = new String(Files.readAllBytes(versionInfoTemplateFile.toPath()));
    } catch (final Throwable e) {
        System.err.println(e.getClass().getName() + ": " + versionInfoTemplateFile.getAbsolutePath() + " 파일을 읽을 수 없습니다.'");
        return false;
    }

    final DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    dateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
    final String date = dateFormat.format(new Date()) + "UTC";
    final String formatted = String.format(content, date, appVersion, gitHash, date);

    try {
        Files.write(versionInfoFile.toPath(), formatted.getBytes());
    } catch (final Throwable e) {
        System.err.println(e.getClass().getName() + ": 파일 기록 실패 (" + e.getMessage() + ")");
        return false;
    }

    if (versionInfoFile.exists()) {
        return true;
    } else {
        System.err.println(versionInfoFile.getAbsolutePath() + " 파일 쓰기 실패");
        return false;
    }
 }

 /**********************************************
 * 예외 스크립트 시작 ! (동기적 실행)
 **********************************************/

 // STEP 0. Arguments 값 분석
 List<String> argsList = parseArgs();
 if (!argsList.contains("local") && !argsList.contains("alpha") && !argsList.contains("release")) {
    System.err.println("Build target 은 local, alpha, release 중 하나여야 합니다.");
    exitCode = 1;
 }

 // STEP 1-1. Gen 디렉토리 삭제 : 삭제되지 않을 때 해당 프린트를 찍는다.
 if (!cleanGenDir()) {
    System.err.println("Codegen 디렉토리 ('lib/gen')를 삭제할 수 없습니다.");
    exitCode = 1;
 }

 // STEP 1-2. 디렉토리를 통째로 lib 아래에 복사
 if (exitCode == 0) {
    if (!putFilesPerBuildPhase(argsList.get(0))) {
        exitCode = 1;
    }
 }

 // STEP 2. Version 추출
 String version = null;
 if (exitCode == 0) {
    version = readVersionFromPubspec();
    if (version == null) {
        System.err.println("Version 형식을 다시 확인해주세요.");
        exitCode = 1;
    }
 }

 // STEP 3. git hash 추출
 String gitHash = null;
 if (exitCode == 0) {
    gitHash = extractGitHash();
    if (gitHash == null) {
        System.err.println("Git Hash 가 없습니다. Build fingerprint 를 '-------' 로 설정합니다.");
        gitHash = "-------";
    }
}

// STEP 4. version_info.dart 파일 생성하기
if (exitCode == 0) {
    if (!putVersionInfo(version, gitHash)) {
        exitCode = 1;
    }
}

/exit exitCode